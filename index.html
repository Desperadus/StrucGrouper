<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AlphaFold UMAP Explorer</title>
    <style>
        :root {
            color-scheme: light dark;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background-color: #f7f7f9;
            color: #1a1a1a;
            overflow-x: hidden;
        }

        header {
            padding: 1.5rem clamp(1rem, 3vw, 3rem);
            background: linear-gradient(90deg, #14213d 0%, #457b9d 100%);
            color: #fff;
        }

        header h1 {
            margin: 0;
            font-size: clamp(1.5rem, 3vw, 2.25rem);
        }

        header p {
            margin: 0.75rem 0 0;
            max-width: 60ch;
            font-size: clamp(0.95rem, 2vw, 1.05rem);
            line-height: 1.5;
        }

        main {
            flex: 1;
            display: grid;
            grid-template-columns: minmax(0, 2.75fr) minmax(320px, 1.75fr);
            gap: clamp(1rem, 2.8vw, 2.25rem);
            padding: clamp(1rem, 3vw, 2.25rem);
            max-width: 1400px;
            width: 100%;
            margin: 0 auto 2rem;
            box-sizing: border-box;
            align-items: stretch;
        }

        @media (max-width: 1000px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: #fff;
            border-radius: 1rem;
            box-shadow: 0 16px 32px rgba(20, 33, 61, 0.12);
            padding: clamp(1rem, 3vw, 1.75rem);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-height: 0;
            box-sizing: border-box;
        }

        .panel h2 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: #14213d;
        }

        label {
            font-weight: 600;
            color: #1f2933;
            display: block;
            margin-bottom: 0.35rem;
        }

        input[type="file"],
        select {
            width: 100%;
            padding: 0.6rem 0.75rem;
            border-radius: 0.75rem;
            border: 1px solid #d1d9e6;
            background-color: #fff;
            font-size: 0.95rem;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        input[type="file"]:focus,
        select:focus {
            outline: none;
            border-color: #457b9d;
            box-shadow: 0 0 0 3px rgba(69, 123, 157, 0.2);
        }

        #plot {
            width: 100%;
            min-height: clamp(320px, 45vh, 640px);
        }

        #molstar-container {
            position: relative;
            flex: 1;
            min-height: clamp(280px, 48vh, 560px);
            border-radius: 0.75rem;
            overflow: hidden;
            background: #f8fafc;
        }

        #molstar-container[data-loading="true"] {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.95rem;
            color: #475569;
            letter-spacing: 0.01em;
        }

        #status {
            font-size: 0.9rem;
            color: #334155;
            background-color: #f1f5f9;
            padding: 0.75rem 0.9rem;
            border-radius: 0.75rem;
            border: 1px solid #e2e8f0;
        }

        .muted {
            color: #64748b;
        }

        .inline-hint {
            font-size: 0.85rem;
            color: #6c7280;
            margin-top: 0.4rem;
        }

        .structure-header {
            display: flex;
            justify-content: space-between;
            gap: 0.5rem;
            align-items: baseline;
        }

        .structure-header h3 {
            margin: 0;
            font-size: 1.1rem;
            color: #243b53;
        }

        .structure-header a {
            font-size: 0.85rem;
            color: #1d72e8;
            text-decoration: none;
        }

        .structure-header a:hover {
            text-decoration: underline;
        }

        #uniprot-meta {
            font-size: 0.9rem;
            color: #334155;
            background-color: #f8fafc;
            padding: 0.7rem 0.9rem;
            border-radius: 0.75rem;
            border: 1px solid #e2e8f0;
            line-height: 1.45;
        }

        #uniprot-meta a {
            color: #1d72e8;
            font-weight: 600;
            text-decoration: none;
        }

        #uniprot-meta a:hover {
            text-decoration: underline;
        }

        .metadata-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .metadata-table th,
        .metadata-table td {
            padding: 0.35rem 0.5rem;
            border-bottom: 1px solid #e2e8f0;
            text-align: left;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.6rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 999px;
            background-color: #eaf4ff;
            color: #1e3a8a;
        }

        .button-inline {
            border: none;
            background: none;
            color: #1d72e8;
            cursor: pointer;
            padding: 0;
            font-size: inherit;
        }

        .button-inline:hover {
            text-decoration: underline;
        }
    </style>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js" defer></script>
    <script src="https://unpkg.com/3dmol@2.0.5/build/3Dmol-min.js" defer></script>
</head>
<body>
    <header>
        <h1>AlphaFold UMAP Explorer</h1>
        <p>Upload a tab-delimited file containing UniProt accessions along with their UMAP coordinates, explore the interactive
            plot, and click any point to view the AlphaFold predicted structure in the embedded 3D viewer. Optionally provide
            a second TSV with per-accession metadata to colour the embedding.</p>
    </header>
    <main>
        <section class="panel" aria-label="data inputs and plot controls">
            <h2>Upload Data</h2>
            <div>
                <label for="coords-file">UMAP coordinates TSV</label>
                <input id="coords-file" type="file" accept=".tsv,.txt,text/tab-separated-values">
                <p class="inline-hint">Expected columns: <code>id</code>, <code>umap_x</code>, <code>umap_y</code>.</p>
            </div>
            <div>
                <label for="metadata-file">Optional metadata TSV</label>
                <input id="metadata-file" type="file" accept=".tsv,.txt,text/tab-separated-values">
                <p class="inline-hint">First column must match the identifiers in the coordinate file. Subsequent columns provide attributes for colouring/search.</p>
            </div>
            <div>
                <label for="colour-by">Colour by</label>
                <select id="colour-by" disabled>
                    <option value="none">No colouring</option>
                </select>
            </div>
            <div id="status" role="status">Awaiting data upload…</div>
            <div id="plot" aria-live="polite"></div>
        </section>

        <aside class="panel" aria-label="structure viewer">
            <div class="structure-header">
                <h3 id="structure-title">Structure viewer</h3>
                <a id="structure-link" href="https://alphafold.ebi.ac.uk/" target="_blank" rel="noopener">Open AlphaFold portal</a>
            </div>
            <div id="structure-meta" class="muted">Select a point in the plot to fetch the corresponding AlphaFold prediction.</div>
            <div id="uniprot-meta" class="muted">UniProt metadata will appear here after selecting a structure.</div>
            <div id="molstar-container" data-loading="true">3D viewer initialising…</div>
            <details>
                <summary>Tips</summary>
                <ul>
                    <li>Scroll or pinch to zoom the plot. Drag to pan.</li>
                    <li>Use lasso/box select via the Plotly toolbar to isolate subsets.</li>
                    <li>Upload your own metadata TSV to colour the embedding by custom annotations.</li>
                    <li>Click any accession in the plot to load its predicted structure in the panel on the right.</li>
                </ul>
            </details>
        </aside>
    </main>
    <script>
        const state = {
            coords: [],
            metadataMap: new Map(),
            metadataFields: [],
            viewer3d: null,
            currentId: null,
            pendingId: null,
            currentIdentifiers: null,
            palette: [
                '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
                '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
                '#bcbddc', '#9edae5', '#fdae6b', '#c994c7', '#6baed6'
            ]
        };

        const coordsInput = document.getElementById('coords-file');
        const metadataInput = document.getElementById('metadata-file');
        const statusBox = document.getElementById('status');
        const colourSelect = document.getElementById('colour-by');
        const structureTitle = document.getElementById('structure-title');
        const structureMeta = document.getElementById('structure-meta');
        const structureLink = document.getElementById('structure-link');
        const plotContainer = document.getElementById('plot');
        const molstarContainer = document.getElementById('molstar-container');
        const uniprotMeta = document.getElementById('uniprot-meta');

        window.addEventListener('load', () => {
            initViewer().catch(error => console.error('[UMAP Explorer] Viewer initialisation failed', error));
        });

        coordsInput.addEventListener('change', handleCoordinateUpload);
        metadataInput.addEventListener('change', handleMetadataUpload);
        colourSelect.addEventListener('change', renderPlot);

        function handleCoordinateUpload(event) {
            const file = event.target.files?.[0];
            if (!file) {
                state.coords = [];
                updateStatus('Awaiting data upload…');
                resetPlot();
                return;
            }
            readFile(file)
                .then(parseTsv)
                .then(rows => {
                    const requiredColumns = ['id', 'umap_x', 'umap_y'];
                    const missing = requiredColumns.filter(column => !(column in rows[0] ?? {}));
                    if (missing.length) {
                        throw new Error(`Coordinate file is missing columns: ${missing.join(', ')}`);
                    }
                    const totalRows = rows.length;
                    state.coords = rows.map(row => {
                        const rawId = String(row.id ?? '').trim();
                        const identifiers = interpretProteinIdentifier(rawId);
                        return {
                            id: identifiers.displayId,
                            x: parseNumber(row.umap_x),
                            y: parseNumber(row.umap_y),
                            metadata: {},
                            identifiers
                        };
                    }).filter(entry => typeof entry.x === 'number' && typeof entry.y === 'number' && entry.id);

                    if (!state.coords.length) {
                        throw new Error('No valid coordinate records found after parsing.');
                    }

                    mergeMetadata();
                    const skipped = totalRows - state.coords.length;
                    const summaryParts = [`Loaded ${state.coords.length.toLocaleString()} coordinate${state.coords.length === 1 ? '' : 's'}.`];
                    if (skipped > 0) {
                        summaryParts.push(`Skipped ${skipped} row${skipped === 1 ? '' : 's'} with missing or invalid coordinates.`);
                    }
                    updateStatus(summaryParts.join(' '));
                    renderPlot();
                })
                .catch(err => {
                    console.error(err);
                    updateStatus(`Failed to parse coordinate file: ${err.message}`, true);
                    state.coords = [];
                    resetPlot();
                });
        }

        function handleMetadataUpload(event) {
            const file = event.target.files?.[0];
            if (!file) {
                state.metadataMap.clear();
                state.metadataFields = [];
                updateColourChoices();
                mergeMetadata();
                renderPlot();
                return;
            }

            readFile(file)
                .then(parseTsv)
                .then(rows => {
                    if (!rows.length || !rows[0].id) {
                        throw new Error('Metadata file must have an "id" column as the first header.');
                    }
                    const metadataMap = new Map();
                    rows.forEach(row => {
                        const { id, ...rest } = row;
                        const trimmedId = String(id ?? '').trim();
                        if (!trimmedId) return;
                        metadataMap.set(trimmedId, rest);
                        const upperId = trimmedId.toUpperCase();
                        if (!metadataMap.has(upperId)) {
                            metadataMap.set(upperId, rest);
                        }
                        const lowerId = trimmedId.toLowerCase();
                        if (!metadataMap.has(lowerId)) {
                            metadataMap.set(lowerId, rest);
                        }
                    });
                    state.metadataMap = metadataMap;
                    const headers = Object.keys(rows[0]);
                    state.metadataFields = headers.filter(header => header !== 'id');
                    updateColourChoices();
                    mergeMetadata();
                    renderPlot();
                    updateStatus(`Metadata loaded with ${state.metadataFields.length} attribute${state.metadataFields.length === 1 ? '' : 's'}.`);
                })
                .catch(err => {
                    console.error(err);
                    updateStatus(`Failed to parse metadata file: ${err.message}`, true);
                    state.metadataMap.clear();
                    state.metadataFields = [];
                    updateColourChoices();
                    mergeMetadata();
                    renderPlot();
                });
        }

        function updateStatus(message, isError = false) {
            statusBox.textContent = message;
            statusBox.style.backgroundColor = isError ? '#fee2e2' : '#f1f5f9';
            statusBox.style.color = isError ? '#b91c1c' : '#334155';
            statusBox.style.borderColor = isError ? '#fecaca' : '#e2e8f0';
        }

        function updateColourChoices() {
            colourSelect.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = 'none';
            defaultOption.textContent = 'No colouring';
            colourSelect.appendChild(defaultOption);

            if (state.metadataFields.length) {
                state.metadataFields.forEach(field => {
                    const option = document.createElement('option');
                    option.value = field;
                    option.textContent = field;
                    colourSelect.appendChild(option);
                });
                colourSelect.disabled = false;
            } else {
                colourSelect.disabled = true;
            }
        }

        function mergeMetadata() {
            if (!state.coords.length) return;
            state.coords.forEach(entry => {
                const identifiers = entry.identifiers ?? {};
                const candidates = [];
                if (entry.id) candidates.push(entry.id);
                if (identifiers.uniprotId) {
                    candidates.push(identifiers.uniprotId);
                    candidates.push(identifiers.uniprotId.toUpperCase());
                    candidates.push(identifiers.uniprotId.toLowerCase());
                }
                let meta = {};
                for (const key of candidates) {
                    if (key && state.metadataMap.has(key)) {
                        meta = state.metadataMap.get(key) ?? {};
                        break;
                    }
                }
                entry.metadata = meta;
            });
        }

        function resetPlot() {
            Plotly.purge(plotContainer);
            plotContainer.innerHTML = '';
        }

        function renderPlot() {
            if (!state.coords.length) {
                resetPlot();
                return;
            }

            const colourField = colourSelect.value;
            const layout = {
                title: '',
                xaxis: { title: 'UMAP 1', zeroline: false },
                yaxis: { title: 'UMAP 2', zeroline: false },
                hovermode: 'closest',
                margin: { l: 60, r: 20, t: 20, b: 60 },
                dragmode: 'pan',
                legend: { orientation: 'h' },
                paper_bgcolor: '#ffffff',
                plot_bgcolor: '#ffffff',
            };

            let plotData = [];

            if (!colourField || colourField === 'none') {
                plotData.push(buildTrace(state.coords, { name: 'Proteins', color: '#1f77b4' }));
            } else {
                const values = state.coords.map(entry => entry.metadata[colourField]);
                const numericValues = values.map(parseNumber);
                const validNumeric = numericValues.every(val => val !== null && isFinite(val));

                if (validNumeric) {
                    plotData.push(buildTrace(state.coords, {
                        name: colourField,
                        colorValues: numericValues,
                        colorScale: 'Viridis',
                        colorBarTitle: colourField
                    }));
                } else {
                    const groups = new Map();
                    state.coords.forEach((entry, index) => {
                        const category = String(values[index] ?? 'NA');
                        if (!groups.has(category)) {
                            groups.set(category, []);
                        }
                        groups.get(category).push(entry);
                    });

                    let paletteIndex = 0;
                    for (const [category, entries] of groups.entries()) {
                        const colour = state.palette[paletteIndex % state.palette.length];
                        paletteIndex += 1;
                        plotData.push(buildTrace(entries, {
                            name: category,
                            color: colour,
                            showLegend: true
                        }));
                    }
                }
            }

            Plotly.newPlot(plotContainer, plotData, layout, {
                responsive: true,
                modeBarButtonsToRemove: ['toImage', 'zoomIn2d', 'zoomOut2d'],
            });

            plotContainer.on('plotly_click', event => {
                const point = event?.points?.[0];
                if (!point) return;
                const id = Array.isArray(point.customdata) ? point.customdata[0] : point.customdata;
                if (id) {
                    loadStructure(id);
                }
            });
        }

        function buildTrace(entries, { name, color, colorValues, colorScale, colorBarTitle, showLegend = false }) {
            const hoverTexts = entries.map(entry => buildHoverText(entry));
            const customData = entries.map(entry => [entry.id]);

            const trace = {
                type: 'scattergl',
                mode: 'markers',
                name,
                x: entries.map(entry => entry.x),
                y: entries.map(entry => entry.y),
                text: hoverTexts,
                hovertemplate: '%{text}<extra></extra>',
                customdata: customData,
                marker: {
                    size: 10,
                    opacity: 0.85,
                    line: { width: 0 },
                },
                showlegend: showLegend,
            };

            if (colorValues) {
                trace.marker.color = colorValues;
                trace.marker.colorscale = colorScale ?? 'Viridis';
                trace.marker.colorbar = { title: colorBarTitle ?? name };
            } else if (color) {
                trace.marker.color = color;
            }

            return trace;
        }

        function buildHoverText(entry) {
            const lines = [
                `<b>${entry.id}</b>`,
                `UMAP 1: ${entry.x.toFixed(3)}`,
                `UMAP 2: ${entry.y.toFixed(3)}`
            ];
            if (entry.identifiers?.alphafoldId && entry.identifiers?.uniprotId) {
                lines.push(`UniProt: ${entry.identifiers.uniprotId}`);
            }
            const metadataEntries = Object.entries(entry.metadata ?? {}).filter(([key, value]) => value !== undefined && value !== null && value !== '');
            metadataEntries.slice(0, 8).forEach(([key, value]) => {
                lines.push(`${key}: ${value}`);
            });
            if (metadataEntries.length > 8) {
                lines.push(`(+${metadataEntries.length - 8} more)`);
            }
            return lines.join('<br>');
        }

        async function loadStructure(rawId) {
            const targetEntry = state.coords.find(entry => entry.id === rawId);
            const identifiers = targetEntry?.identifiers ?? interpretProteinIdentifier(rawId);
            const displayId = identifiers.displayId || rawId;
            if (!displayId) {
                return;
            }

            if (state.pendingId === displayId) {
                return;
            }

            state.pendingId = displayId;
            state.currentIdentifiers = null;
            structureTitle.textContent = `Loading ${displayId}…`;
            structureMeta.textContent = 'Downloading AlphaFold model…';
            structureMeta.classList.add('muted');
            const portalId = identifiers.uniprotId || displayId;
            structureLink.href = `https://alphafold.ebi.ac.uk/entry/${encodeURIComponent(portalId)}`;
            if (uniprotMeta) {
                if (identifiers.uniprotId) {
                    uniprotMeta.textContent = 'Fetching UniProt metadata…';
                } else {
                    uniprotMeta.textContent = 'UniProt accession not detected for this identifier.';
                }
                uniprotMeta.classList.add('muted');
            }

            try {
                const viewer = await initViewer();

                viewer.removeAllModels?.();
                viewer.removeAllSurfaces?.();
                viewer.render?.();

                const sources = [
                    ...buildAlphaFoldFileCandidates(identifiers),
                    ...buildAlphaFoldProxyCandidates(identifiers)
                ];
                let sourceUsed = null;
                let lastError = null;

                for (const source of sources) {
                    try {
                        console.debug('[UMAP Explorer] Attempting structure load', source.url);
                        await loadModelIntoViewer(viewer, source);
                        sourceUsed = source.url;
                        break;
                    } catch (err) {
                        lastError = err;
                        console.warn('[UMAP Explorer] Failed to load structure from', source.url, err);
                        viewer.removeAllModels?.();
                        viewer.removeAllSurfaces?.();
                        viewer.render?.();
                    }
                }

                if (!sourceUsed) {
                    throw lastError ?? new Error('No AlphaFold structure files could be loaded for this accession.');
                }

                viewer.setStyle({}, { cartoon: { color: 'spectrum' } });
                viewer.zoomTo();
                viewer.render();

                state.currentId = displayId;
                state.currentIdentifiers = identifiers;
                state.pendingId = null;
                structureTitle.textContent = displayId;
                structureMeta.innerHTML = `<span class="pill">AlphaFold</span> Model loaded from<br>${escapeHtml(sourceUsed)}`;
                structureMeta.classList.remove('muted');

                if (identifiers.uniprotId) {
                    fetchAlphaFoldMetadata(identifiers.uniprotId)
                        .then(metadata => {
                            if (!metadata || state.currentId !== displayId) return;
                            const { description, organism, confidenceText } = metadata;
                            const metaLines = [
                                confidenceText ? `<span class="pill">pLDDT: ${escapeHtml(confidenceText)}</span>` : '',
                                description ? escapeHtml(description) : '',
                                organism ? escapeHtml(organism) : ''
                            ].filter(Boolean);
                            if (metaLines.length) {
                                structureMeta.innerHTML = metaLines.join('<br>');
                            }
                        })
                        .catch(err => {
                            console.warn('[UMAP Explorer] Metadata fetch failed (non-critical)', err);
                        });

                    if (uniprotMeta) {
                        fetchUniProtMetadata(identifiers.uniprotId)
                            .then(data => {
                                if (!data || state.currentId !== displayId) return;
                                const details = [];
                                const uniProtLink = `https://www.uniprot.org/uniprotkb/${encodeURIComponent(data.accession)}/entry`;
                                details.push(`<a href="${uniProtLink}" target="_blank" rel="noopener">View on UniProt</a>`);
                                if (data.proteinName) {
                                    details.push(`<strong>${escapeHtml(data.proteinName)}</strong>`);
                                }
                                if (data.geneNames?.length) {
                                    const genes = data.geneNames.map(name => escapeHtml(name));
                                    details.push(`Gene: ${genes.join(', ')}`);
                                }
                                if (data.organism) {
                                    details.push(escapeHtml(data.organism));
                                }
                                if (typeof data.length === 'number') {
                                    details.push(`Length: ${data.length.toLocaleString()} aa`);
                                }
                                if (data.functionText) {
                                    details.push(escapeHtml(data.functionText));
                                }
                                uniprotMeta.innerHTML = details.join('<br>');
                                uniprotMeta.classList.remove('muted');
                            })
                            .catch(err => {
                                if (state.currentId !== displayId) return;
                                console.warn('[UMAP Explorer] UniProt metadata fetch failed (non-critical)', err);
                                uniprotMeta.textContent = 'UniProt metadata unavailable.';
                                uniprotMeta.classList.add('muted');
                            });
                    }
                } else if (uniprotMeta) {
                    uniprotMeta.classList.add('muted');
                }
            } catch (error) {
                structureTitle.textContent = displayId;
                structureMeta.textContent = `Failed to load model: ${error.message}`;
                structureMeta.classList.add('muted');
                if (uniprotMeta) {
                    uniprotMeta.textContent = 'UniProt metadata unavailable.';
                    uniprotMeta.classList.add('muted');
                }
                state.currentIdentifiers = null;
                state.pendingId = null;
                console.error('[UMAP Explorer] Structure load failed', error);
            }
        }

        async function initViewer() {
            if (state.viewer3d) return state.viewer3d;

            if (molstarContainer && !molstarContainer.hasAttribute('data-loading')) {
                molstarContainer.setAttribute('data-loading', 'true');
                molstarContainer.textContent = '3D viewer initialising…';
            }

            await waitFor3DMol();
            const lib = window.$3Dmol;
            if (!lib?.GLViewer) {
                if (molstarContainer) {
                    molstarContainer.textContent = '3D viewer script failed to load.';
                }
                throw new Error('3Dmol library not available on window object.');
            }

            if (molstarContainer) {
                molstarContainer.textContent = '';
            }
            const viewer = lib.createViewer(molstarContainer, {
                backgroundColor: '#ffffff',
                antialias: true,
            });
            viewer.setBackgroundColor(0xffffff);
            molstarContainer?.removeAttribute('data-loading');
            molstarContainer?.classList.add('viewer-ready');

            state.viewer3d = viewer;
            return viewer;
        }

        function waitFor3DMol() {
            return new Promise((resolve, reject) => {
                const checkReady = () => {
                    if (window.$3Dmol?.GLViewer) {
                        resolve();
                        return true;
                    }
                    return false;
                };

                if (checkReady()) return;

                const interval = setInterval(() => {
                    if (checkReady()) {
                        clearInterval(interval);
                        clearTimeout(timeout);
                    }
                }, 60);

                const timeout = setTimeout(() => {
                    clearInterval(interval);
                    reject(new Error('Timed out waiting for 3Dmol script to load.'));
                }, 8000);
            });
        }

        function loadModelIntoViewer(viewer, source) {
            return new Promise((resolve, reject) => {
                if (!window.$3Dmol?.download) {
                    reject(new Error('3Dmol download helper unavailable.'));
                    return;
                }
                const fetchOptions = source.url.startsWith('/fetch-structure')
                    ? { cache: 'no-cache', credentials: 'same-origin' }
                    : { cache: 'no-cache', mode: 'cors', credentials: 'omit' };

                fetch(source.url, fetchOptions)
                    .then(resp => {
                        if (!resp.ok) {
                            throw new Error(`HTTP ${resp.status} while fetching structure.`);
                        }
                        return resp.text();
                    })
                    .then(text => {
                        const format = source.format === 'mmcif' ? 'mmcif' : 'pdb';
                        const model = viewer.addModel(text, format);
                        if (!model) {
                            throw new Error('Empty structure received.');
                        }
                        resolve(model);
                    })
                    .catch(reject);
            });
        }

        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsText(file);
            });
        }

        function parseTsv(rawText) {
            const text = (rawText ?? '').trim();
            if (!text) return [];

            const lines = text.split(/\r?\n/).filter(Boolean);
            const headers = splitRow(lines[0]);
            if (!headers.length) return [];

            return lines.slice(1).map(line => {
                const values = splitRow(line);
                const record = {};
                headers.forEach((header, index) => {
                    record[header] = values[index] ?? '';
                });
                return record;
            });
        }

        function splitRow(line) {
            if (line.includes('\t')) {
                return line.split('\t').map(token => token.trim());
            }
            return line.trim().split(/\s+/);
        }

        function parseNumber(value) {
            if (value === undefined || value === null || value === '') return null;
            const num = Number(value);
            return Number.isFinite(num) ? num : null;
        }

        function interpretProteinIdentifier(rawId) {
            const trimmed = String(rawId ?? '').trim();
            if (!trimmed) {
                return { displayId: '', uniprotId: '', alphafoldId: null, isAlphaFoldModel: false };
            }
            const alphaFoldMatch = /^AF-([^-]+)-F\d+-model_v\d+$/i.exec(trimmed);
            if (alphaFoldMatch) {
                const uniprot = alphaFoldMatch[1];
                return {
                    displayId: trimmed,
                    uniprotId: uniprot.toUpperCase(),
                    alphafoldId: trimmed,
                    isAlphaFoldModel: true,
                };
            }
            return {
                displayId: trimmed,
                uniprotId: trimmed.toUpperCase(),
                alphafoldId: null,
                isAlphaFoldModel: false,
            };
        }

        async function fetchUniProtMetadata(uniprotId) {
            if (!uniprotId) return null;
            const apiUrl = `https://rest.uniprot.org/uniprotkb/${encodeURIComponent(uniprotId)}.json`;
            try {
                const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
                const timeout = controller ? setTimeout(() => controller.abort(), 10000) : null;
                const response = await fetch(apiUrl, {
                    headers: { 'Accept': 'application/json' },
                    signal: controller?.signal,
                    mode: 'cors',
                    credentials: 'omit',
                });
                if (timeout) clearTimeout(timeout);
                if (!response.ok) {
                    throw new Error(`UniProt API returned ${response.status}`);
                }
                const data = await response.json();
                const accession = data.primaryAccession ?? uniprotId;
                const proteinName =
                    data.proteinDescription?.recommendedName?.fullName?.value ??
                    data.proteinDescription?.submissionNames?.[0]?.fullName?.value ??
                    '';
                const organismParts = [];
                if (data.organism?.scientificName) {
                    organismParts.push(data.organism.scientificName);
                }
                if (data.organism?.commonName && data.organism.commonName !== data.organism?.scientificName) {
                    organismParts.push(`(${data.organism.commonName})`);
                }
                const organism = organismParts.join(' ').trim();
                const geneNamesSet = new Set();
                (data.genes ?? []).forEach(gene => {
                    if (gene?.geneName?.value) {
                        geneNamesSet.add(gene.geneName.value);
                    }
                    (gene?.synonyms ?? []).forEach(syn => {
                        if (syn?.value) {
                            geneNamesSet.add(syn.value);
                        }
                    });
                });
                const geneNames = Array.from(geneNamesSet).slice(0, 4);
                const length = typeof data.sequence?.length === 'number' ? data.sequence.length : null;
                let functionText = null;
                if (Array.isArray(data.comments)) {
                    const functionComment = data.comments.find(comment => comment.commentType === 'FUNCTION');
                    const textValue = functionComment?.texts?.[0]?.value;
                    if (textValue) {
                        const normalised = normaliseWhitespace(textValue);
                        functionText = truncateText(normalised, 260);
                    }
                }
                return {
                    accession,
                    proteinName: proteinName ? normaliseWhitespace(proteinName) : '',
                    organism,
                    geneNames,
                    length,
                    functionText,
                };
            } catch (error) {
                throw error;
            }
        }

        function normaliseWhitespace(value) {
            return String(value ?? '').replace(/\s+/g, ' ').trim();
        }

        function truncateText(value, maxLength) {
            const text = String(value ?? '').trim();
            if (!text) return '';
            if (text.length <= maxLength) {
                return text;
            }
            const truncated = text.slice(0, maxLength);
            const lastSpace = truncated.lastIndexOf(' ');
            const safeCut = lastSpace > 40 ? truncated.slice(0, lastSpace) : truncated;
            return `${safeCut}...`;
        }

        function escapeHtml(value) {
            const str = String(value ?? '');
            const replacements = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;',
            };
            return str.replace(/[&<>"']/g, char => replacements[char] ?? char);
        }

        function buildAlphaFoldFileCandidates(identifier) {
            const info = typeof identifier === 'string' ? interpretProteinIdentifier(identifier) : (identifier ?? {});
            const sources = [];

            if (info.alphafoldId) {
                const safeModel = encodeURIComponent(info.alphafoldId);
                sources.push({ url: `https://alphafold.ebi.ac.uk/files/${safeModel}.pdb`, format: 'pdb' });
                sources.push({ url: `https://alphafold.ebi.ac.uk/files/${safeModel}.cif`, format: 'mmcif' });
            }

            if (info.uniprotId) {
                const safeId = encodeURIComponent(info.uniprotId);
                const versions = ['v6', 'v5', 'v4', 'v3', 'v2', 'v1'];
                const base = (version, extension) => `https://alphafold.ebi.ac.uk/files/AF-${safeId}-F1-model_${version}.${extension}`;
                versions.forEach(version => {
                    sources.push({ url: base(version, 'pdb'), format: 'pdb' });
                });
                versions.forEach(version => {
                    sources.push({ url: base(version, 'cif'), format: 'mmcif' });
                });
            }

            return sources;
        }

        function buildAlphaFoldProxyCandidates(identifier) {
            const info = typeof identifier === 'string' ? interpretProteinIdentifier(identifier) : (identifier ?? {});
            const uniprotId = info.uniprotId;
            if (!uniprotId) return [];
            const safeId = encodeURIComponent(uniprotId);
            const base = (extension) => `/fetch-structure?format=${extension}&id=${safeId}`;
            return [
                { url: base('pdb'), format: 'pdb' },
                { url: base('cif'), format: 'mmcif' },
            ];
        }

        async function fetchAlphaFoldMetadata(uniprotId) {
            const apiUrl = `https://alphafold.ebi.ac.uk/api/prediction/${encodeURIComponent(uniprotId)}`;
            try {
                const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
                const timeout = controller ? setTimeout(() => controller.abort(), 10000) : null;
                const response = await fetch(apiUrl, {
                    headers: { 'Accept': 'application/json' },
                    signal: controller?.signal,
                    mode: 'cors',
                    credentials: 'omit',
                });
                if (timeout) clearTimeout(timeout);
                if (!response.ok) {
                    throw new Error(`AlphaFold API returned ${response.status}`);
                }
                const models = await response.json();
                const model = models?.[0];
                if (!model) return null;
                const description = model.uniprotDescription ?? model.proteinDescription ?? '';
                const organism = model.organismScientificName ?? '';
                const confidence = typeof model.globalMetricValue === 'number' ? model.globalMetricValue : null;
                const confidenceText = confidence !== null ? confidence.toFixed(1) : null;
                return { description, organism, confidenceText };
            } catch (error) {
                throw error;
            }
        }
    </script>
</body>
</html>
